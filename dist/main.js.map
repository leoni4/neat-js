{"version":3,"file":"main.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,MAAM,I,0cCTT,eACA,SACA,SAEA,mBAKIC,YAAYC,GAJZ,WAA2B,IAC3B,WAA4B,IAC5B,WAA4B,IAGxB,MAAMC,EAAQD,EAAOC,MACfC,EAAcF,EAAOE,YAErBC,EAAiC,IAAIC,IAE3C,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAMK,KAAKC,OAAQF,GAAK,EAAG,CAC3C,MAAMG,EAAIP,EAAMK,KAAKD,GACrB,GAAIG,aAAa,EAAAC,eAAgB,SACjC,MAAMC,EAAa,IAAI,EAAAC,KAAKH,EAAEI,GAC9BT,EAAYU,IAAIL,EAAEM,iBAAkBJ,GAEhCF,EAAEI,GAAK,GACP,EAAAG,KAAI,OAAaC,KAAKN,GACfF,EAAEI,GAAK,GACd,EAAAG,KAAI,OAAcC,KAAKN,GAEvB,EAAAK,KAAI,OAAcC,KAAKN,GAG/B,EAAAK,KAAI,OAAcE,MAAK,CAACC,EAAGC,IAChBD,EAAEE,UAAUD,KAGvB,IAAK,IAAId,EAAI,EAAGA,EAAIH,EAAYI,KAAKC,OAAQF,GAAK,EAAG,CACjD,MAAMgB,EAAInB,EAAYI,KAAKD,GAC3B,GAAIgB,aAAa,EAAAC,SAAU,SAE3B,MAAMC,EAAiBF,EAAEE,KACnBC,EAAeH,EAAEG,GAEjBC,EAAWtB,EAAYuB,IAAIH,EAAKT,kBAChCa,EAASxB,EAAYuB,IAAIF,EAAGV,kBAClC,IAAKW,IAAaE,EAAQ,SAE1B,MAAMC,EAAM,IAAI,EAAAC,WAAWJ,EAAUE,GACrCC,EAAIE,OAAST,EAAES,OACfF,EAAIG,QAAUV,EAAEU,QAEhBJ,EAAOzB,YAAYc,KAAKY,IAIhCI,UAAUC,GACN,GAAIA,EAAM1B,SAAW,EAAAQ,KAAI,OAAaR,OAAQ,MAAM,IAAI2B,MAAM,mBAC9D,IAAK,IAAI7B,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAaR,OAAQF,IACzC,EAAAU,KAAI,OAAaV,GAAG8B,OAASF,EAAM5B,GAEvC,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAcR,OAAQF,IAC1C,EAAAU,KAAI,OAAcV,GAAG2B,YAEzB,MAAMG,EAAS,IAAIC,MAAc,EAAArB,KAAI,OAAcR,QACnD,IAAK,IAAIF,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAcR,OAAQF,IAC1C,EAAAU,KAAI,OAAcV,GAAG2B,YACrBG,EAAO9B,GAAK,EAAAU,KAAI,OAAcV,GAAG8B,OAErC,OAAOA,I,w2BC/Df,mBAMIpC,YAAYwB,EAAYC,GALxB,mBACA,mBACA,WAAU,GACV,YAAW,GAGP,EAAAT,KAAI,EAASQ,EAAI,KACjB,EAAAR,KAAI,EAAOS,EAAE,KAGbD,WACA,OAAO,EAAAR,KAAI,OAGXQ,SAAKc,GACL,EAAAtB,KAAI,EAASsB,EAAK,KAGlBb,SACA,OAAO,EAAAT,KAAI,OAGXS,OAAGa,GACH,EAAAtB,KAAI,EAAOsB,EAAK,KAGhBP,aACA,OAAO,EAAAf,KAAI,OAGXe,WAAOO,GACP,EAAAtB,KAAI,EAAWsB,EAAK,KAGpBN,cACA,OAAO,EAAAhB,KAAI,OAGXgB,YAAQM,GACR,EAAAtB,KAAI,EAAYsB,EAAK,O,k3BCxC7B,aAKItC,YAAYa,G,YAJZ,mBACA,WAAU,GACV,WAAkC,IAG9B,EAAAG,KAAI,EAAMH,EAAC,KAGXA,QACA,OAAO,EAAAG,KAAI,OAGXH,MAAEyB,GACF,EAAAtB,KAAI,EAAMsB,EAAK,KAGfF,aACA,OAAO,EAAApB,KAAI,OAGXoB,WAAOE,GACP,EAAAtB,KAAI,EAAWsB,EAAK,KAGpBnC,kBACA,OAAO,EAAAa,KAAI,OAGXb,gBAAYmC,GACZ,EAAAtB,KAAI,EAAgBsB,EAAK,KAO7BL,YACI,IAAIM,EAAM,EACV,IAAK,IAAIjC,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAcR,OAAQF,GAAK,EAAG,CAClD,MAAMgB,EAAI,EAAAN,KAAI,OAAcV,GACxBgB,EAAEU,UACFO,GAAOjB,EAAES,OAAST,EAAEE,KAAKY,QAGjC,EAAApB,KAAI,EAAW,EAAAA,KAAI,SAAY,KAAhBA,KAAiBuB,GAAI,KAGxClB,UAAUV,GACN,OAAIK,KAAKH,EAAIF,EAAKE,EACP,EACAG,KAAKH,EAAIF,EAAKE,GACb,EAED,I,mEArBH0B,GACR,OAAO,GAAK,EAAIC,KAAKC,KAAKF,M,wfCpClC,YACA,YACA,a,yfCFA,YACA,a,8zBCDA,eAEA,sBAIIvC,cAHA,mBACA,mBAGI,EAAAgB,KAAI,EAAQ,IAAI0B,IAAK,KACrB,EAAA1B,KAAI,EAAS,GAAE,KAGnB2B,SAASC,GACL,IAAID,GAAW,EACf,IAAK,IAAIrC,EAAI,EAAGA,EAAIU,KAAKT,KAAKC,OAAQF,GAAK,EACnCU,KAAKT,KAAKD,GAAGS,mBAAqB6B,EAAK7B,mBACvC4B,GAAW,GAGnB,OAAOA,EAGXE,gBACI,OAAK,EAAA7B,KAAI,OAAM8B,KAGR,EAAA9B,KAAI,OAAOwB,KAAKO,MAAM,EAAA/B,KAAI,OAAOR,OAASgC,KAAKQ,WAF3C,KAKfC,IAAIL,GACK5B,KAAK2B,SAASC,KACf,EAAA5B,KAAI,OAAMiC,IAAIL,GACd,EAAA5B,KAAI,OAAOC,KAAK2B,IAIxBM,UAAUN,GACN,IAAK5B,KAAK2B,SAASC,GAAO,CACtB,IAAK,IAAItC,EAAI,EAAGA,EAAIU,KAAK8B,OAAQxC,IAAK,CAClC,MAAM6C,EAAanC,KAAKW,IAAIrB,GAAGS,iBAC/B,GAAI6B,EAAK7B,iBAAmBoC,EAGxB,OAFA,EAAAnC,KAAI,OAAOoC,OAAO9C,EAAG,EAAGsC,QACxB,EAAA5B,KAAI,OAAMiC,IAAIL,GAItB,EAAA5B,KAAI,OAAMiC,IAAIL,GACd,EAAA5B,KAAI,OAAOC,KAAK2B,IAIxBE,OACI,OAAO,EAAA9B,KAAI,OAAOR,OAGtB6C,QACI,EAAArC,KAAI,OAAMqC,QACV,EAAArC,KAAI,EAAS,GAAE,KAGnBW,IAAI2B,GACA,OAAO,EAAAtC,KAAI,OAAOsC,GAGtBC,OAAOC,GACH,GAAIA,aAAe,EAAA9C,eAAgB,CAC/B,MAAM4C,EAAQ,EAAAtC,KAAI,OAAOyC,QAAQD,GACjC,EAAAxC,KAAI,OAAOoC,OAAOE,EAAO,GACzB,EAAAtC,KAAI,OAAM0C,OAAOF,OACd,CACH,GAAIA,EAAM,GAAKA,GAAO,EAAAxC,KAAI,OAAM8B,KAC5B,OAEJ,EAAA9B,KAAI,OAAM0C,OAAO,EAAA1C,KAAI,OAAOwC,IAC5B,EAAAxC,KAAI,OAAOoC,OAAOI,EAAK,IAI3BjD,WACA,OAAO,EAAAS,KAAI,S,41BC5EnB,uBAKIhB,YAAY2D,GAJZ,WAA2B,IAC3B,mBACA,WAAc,GAGV,EAAA3C,KAAI,EAAc2C,EAAS,KAG/BV,IAAIW,GACA,EAAA5C,KAAI,OAAUC,KAAK2C,GACnB,EAAA5C,KAAA,IAAAA,KAAA,OAAoB4C,EAAOC,MAAK,KAChC,EAAA7C,KAAI,OAAUE,MAAK,CAACC,EAAGC,IACZD,EAAE0C,MAAQzC,EAAEyC,OAAS,EAAI,IAIxCb,SACI,MAAMc,EAActB,KAAKuB,IAAIvB,KAAKQ,SAAW,EAAAhC,KAAI,OAAe,EAAAA,KAAI,QACpE,IAAIgD,EAAa,EACjB,IAAK,IAAI1D,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,IAEtC,GADA0D,GAAcxB,KAAKuB,IAAI,EAAA/C,KAAI,OAAUV,GAAGuD,OACpCG,GAAcF,EACd,OAAO,EAAA9C,KAAI,OAAUV,GAG7B,MAAM,IAAI6B,MAAM,4BAGpB8B,QACI,EAAAjD,KAAI,EAAY,GAAE,KAClB,EAAAA,KAAI,EAAe,EAAC,O,g3BCjC5B,eAEA,SAEA,MAAaN,UAAuB,EAAAwD,KAQhClE,YAAYe,EAA0BS,EAAgBC,GAClD0C,MAAMpD,GARV,mBACA,mBACA,WAAU,GACV,YAAW,GAEX,WAAgB,GAIZ,EAAAC,KAAI,EAASQ,EAAI,KACjB,EAAAR,KAAI,EAAOS,EAAE,KAGb2C,mBACA,OAAO,EAAApD,KAAI,OAGXoD,iBAAa9B,GACb,EAAAtB,KAAI,EAAiBsB,EAAK,KAG1Bd,WACA,OAAO,EAAAR,KAAI,OAGXQ,SAAKc,GACL,EAAAtB,KAAI,EAASsB,EAAK,KAGlBb,SACA,OAAO,EAAAT,KAAI,OAGXS,OAAGa,GACH,EAAAtB,KAAI,EAAOsB,EAAK,KAGhBP,aACA,OAAO,EAAAf,KAAI,OAGXe,WAAOO,GACP,EAAAtB,KAAI,EAAWsB,EAAK,KAGpBN,cACA,OAAO,EAAAhB,KAAI,OAGXgB,YAAQM,GACR,EAAAtB,KAAI,EAAYsB,EAAK,KAGzB+B,aACI,MAAO,GAAGrD,KAAKQ,KAAKT,oBAAoBC,KAAKQ,KAAKX,KAAKG,KAAKS,GAAGV,oBAAoBC,KAAKS,GAAGZ,IAG/FyD,OAAOC,GACH,OAAMA,aAAe7D,GAEdM,KAAKQ,KAAK8C,OAAOC,EAAI/C,OAASR,KAAKS,GAAG6C,OAAOC,EAAI9C,IAG5D+C,WACI,OAAOxD,KAAKQ,KAAKT,iBAAmB,EAAA0D,KAAKC,UAAY1D,KAAKS,GAAGV,kBAjErE,mB,w3BCJA,aAGIf,YAAYe,GAFZ,mBAGI,EAAAC,KAAI,EAAqBD,EAAgB,KAGzCA,uBACA,OAAO,EAAAC,KAAI,OAGXD,qBAAiBuB,GACjB,EAAAtB,KAAI,EAAqBsB,EAAK,O,g1BCZtC,eACA,SACA,SACA,SAEA,eAOItC,YAAY2E,G,YANZ,WAA8B,IAAI,EAAAC,eAClC,WAAwB,IAAI,EAAAA,eAC5B,mBACA,mBACA,YAAW,GAGP,EAAA5D,KAAI,EAAS2D,EAAI,KACjB,EAAA3D,KAAI,EAAoB2D,EAAKE,kBAAiB,KAG9CC,cACA,OAAO,EAAA9D,KAAI,OAGX+D,sBACA,OAAO,EAAA/D,KAAI,OAGXb,kBACA,OAAO,EAAAa,KAAI,OAGXd,YACA,OAAO,EAAAc,KAAI,OAGX2D,WACA,OAAO,EAAA3D,KAAI,OAGfgE,SAASC,GACL,IAAIC,EAAalE,KAEjB,MAAMmE,EAAsCD,EAAG/E,YAAYwB,IAAIuD,EAAG/E,YAAY2C,OAAS,GACjFsC,EAAsCH,EAAG9E,YAAYwB,IAAIsD,EAAG9E,YAAY2C,OAAS,GAIvF,IAFwBqC,aAAoB,EAAAzE,eAAiByE,EAASpE,iBAAmB,IACjEqE,aAAoB,EAAA1E,eAAiB0E,EAASrE,iBAAmB,GAClD,CACnC,MAAMsE,EAAQH,EACdA,EAAKD,EACLA,EAAKI,EAGT,IAAIC,EAAU,EACVC,EAAU,EAEVC,EAAW,EACXC,EAAa,EACbC,EAAU,EACd,KAAOJ,EAAUJ,EAAG/E,YAAY2C,QAAUyC,EAAUN,EAAG9E,YAAY2C,QAAQ,CACvE,MAAM6C,EAAmCT,EAAG/E,YAAYwB,IAAI2D,GACtDM,EAAmCX,EAAG9E,YAAYwB,IAAI4D,GAC5D,KAAMI,aAAiB,EAAAjF,gBAAqBkF,aAAiB,EAAAlF,gBACzD,MAAM,IAAIyB,MAAM,gCAEpB,MAAM0D,EAAeF,EAAM5E,iBACrB+E,EAAeF,EAAM7E,iBAEvB8E,EAAOC,GACPP,IACAC,KACOK,EAAOC,GACdR,IACAE,MAEAF,IACAC,IACAG,IACAD,GAAcjD,KAAKuB,IAAI4B,EAAM5D,OAAS6D,EAAM7D,SAIpD0D,GAAcC,GAAW,EAEzB,MAAMK,EAASb,EAAG/E,YAAY2C,OAASwC,EACvC,IAAIU,EAAIxD,KAAKyD,IAAIf,EAAG/E,YAAY2C,OAAQmC,EAAG9E,YAAY2C,QAGvD,OAFAkD,EAAIA,EAAI,EAAAhF,KAAI,OAAOkF,GAAK,EAAIF,EAEpB,EAAAhF,KAAI,OAAOmF,GAAKJ,EAAUC,EAAK,EAAAhF,KAAI,OAAOoF,GAAKZ,EAAYQ,EAAI,EAAAhF,KAAI,OAAOqF,GAAKZ,EAG3Fa,iBAAiBpB,EAAYD,GACzB,MAAMhF,EAAiBiF,EAAGP,KAAK4B,cAE/B,IAAIjB,EAAU,EACVC,EAAU,EAEd,KAAOD,EAAUJ,EAAG/E,YAAY2C,QAAUyC,EAAUN,EAAG9E,YAAY2C,QAAQ,CACvE,MAAM6C,EAAQT,EAAG/E,YAAYwB,IAAI2D,GAC3BM,EAAQX,EAAG9E,YAAYwB,IAAI4D,GACjC,KAAMI,aAAiB,EAAAjF,gBAAqBkF,aAAiB,EAAAlF,gBACzD,MAAM,IAAIyB,MAAM,gCAEpB,MAAM0D,EAAeF,EAAM5E,iBACrB+E,EAAeF,EAAM7E,iBAC3B,IAAIyF,EAAkC,KAClCX,EAAOC,EACPP,IACOM,EAAOC,GACTZ,EAAGJ,SAAY7E,EAAO0E,KAAK8B,eAAgBd,EAAM3D,UAClDwE,EAAW,EAAA/B,KAAKiC,cAAcf,IAElCL,QAEMJ,EAAGJ,UAAYG,EAAGH,UAAa7E,EAAO0E,KAAK8B,cAAiBd,EAAM3D,SAAW4D,EAAM5D,WAEjFwE,EADAhE,KAAKQ,SAAW,GACL,EAAAyB,KAAKiC,cAAcf,GAEnB,EAAAlB,KAAKiC,cAAcd,IAGtCN,IACAC,KAEEiB,aAAoB,EAAA9F,gBAG1BT,EAAOE,YAAY+C,UAAUsD,GAEjC,KAAOlB,EAAUJ,EAAG/E,YAAY2C,QAAQ,CACpC,MAAM6C,EAAQT,EAAG/E,YAAYwB,IAAI2D,GACjC,KAAMK,aAAiB,EAAAjF,gBACnB,MAAM,IAAIyB,MAAM,gCAGf+C,EAAGP,KAAK8B,eAAgBd,EAAM3D,SAC/B/B,EAAOE,YAAY+C,UAAU,EAAAuB,KAAKiC,cAAcf,IAEpDL,IAEJ,IAAK,IAAIhF,EAAI,EAAGA,EAAIL,EAAOE,YAAYI,KAAKC,OAAQF,IAAK,CACrD,MAAMqG,EAAO1G,EAAOE,YAAYwB,IAAIrB,GACpC,KAAMqG,aAAgB,EAAAjG,gBAClB,MAAM,IAAIyB,MAAM,gCAEpBlC,EAAOC,MAAM+C,IAAI0D,EAAKnF,MACtBvB,EAAOC,MAAM+C,IAAI0D,EAAKlF,IAG1B,OAAOxB,EAGX2G,aACI,IAAIC,EAAQ,EAAA7F,KAAI,OAAQ6B,gBACpBiE,EAAQ,EAAA9F,KAAI,OAAQ6B,gBAExB,KAAMgE,aAAiB,EAAAtF,UAAeuF,aAAiB,EAAAvF,UACnD,OAAO,KAGX,KAAOuF,aAAiB,EAAAvF,UAAYsF,EAAMhG,IAAMiG,EAAMjG,GAClDiG,EAAQ,EAAA9F,KAAI,OAAQ6B,gBAGxB,KAAMiE,aAAiB,EAAAvF,UACnB,OAAO,KAGX,GAAIsF,EAAMhG,EAAIiG,EAAMjG,EAAG,CACnB,MAAMkG,EAAOF,EACbA,EAAQC,EACRA,EAAQC,EAEZ,IAAIC,GAAS,EAOb,GANA,EAAAhG,KAAI,OAAcT,KAAK0G,SAAQC,IACvBA,aAAgB,EAAA3F,UAChB2F,EAAK1F,OAASqF,GAASK,EAAKzF,KAAOqF,IACnCE,GAAS,MAGbA,EACA,OAAO,KAGX,MAAMnF,EAAsB,EAAAb,KAAI,OAAO0F,cAAcG,EAAOC,GAI5D,OAHAjF,EAAIE,QAA0B,EAAhBS,KAAKQ,SAAe,GAAK,EAAAhC,KAAI,OAAOmG,uBAElD,EAAAnG,KAAI,OAAckC,UAAUrB,GACrBA,EAGXuF,aACI,MAAMvF,EAAM,EAAAb,KAAI,OAAc6B,gBAC9B,KAAMhB,aAAe,EAAAnB,gBACjB,OAAO,KAGX,MAAMc,EAAiBK,EAAIL,KACrBC,EAAeI,EAAIJ,GACnB2C,EAAe,EAAApD,KAAI,OAAOqG,gBAAgB7F,EAAMC,GACtD,IAAI6F,EACiB,IAAjBlD,GACAkD,EAAS,EAAAtG,KAAI,OAAOuG,UACpBD,EAAOzG,GAAKW,EAAKX,EAAIY,EAAGZ,GAAK,EAC7ByG,EAAOE,GAAKhG,EAAKgG,EAAI/F,EAAG+F,GAAK,EAAoB,GAAhBhF,KAAKQ,SAAiB,GACvDsE,EAAOE,EAAIF,EAAOE,EAAI,GAAM,GAAMF,EAAOE,EAAI,GAAM,GAAMF,EAAOE,EAChE,EAAAxG,KAAI,OAAOyG,gBAAgBjG,EAAMC,EAAI6F,EAAOvG,mBAE5CuG,EAAS,EAAAtG,KAAI,OAAOuG,QAAQnD,GAGhC,MAAMsD,EAAuB,EAAA1G,KAAI,OAAO0F,cAAclF,EAAM8F,GACtDK,EAAuB,EAAA3G,KAAI,OAAO0F,cAAcY,EAAQ7F,GAC9D,IAAImG,GAAU,EACVC,GAAU,EAwBd,OAvBA,EAAA7G,KAAI,OAAcT,KAAK0G,SAAQC,IACvBA,aAAgB,EAAA3F,WAChB2F,EAAK1F,OAASA,GAAQ0F,EAAKzF,KAAO6F,IAClCM,GAAU,GAEVV,EAAK1F,OAAS8F,GAAUJ,EAAKzF,KAAOA,IACpCoG,GAAU,OAGbD,IACDF,EAAK3F,OAAS,EACd4F,EAAK5F,OAASF,EAAIE,OAClB,EAAAf,KAAI,OAAckC,UAAUwE,IAE3BG,IACDF,EAAK3F,QAAUH,EAAIG,QACnB,EAAAhB,KAAI,OAAckC,UAAUyE,IAE3BC,GAAYC,IACbhG,EAAIG,SAAU,GAGlB,EAAAhB,KAAI,OAAQiC,IAAIqE,GACTA,EAGXQ,oBACI,MAAMjG,EAAM,EAAAb,KAAI,OAAc6B,gBAC9B,KAAMhB,aAAe,EAAAnB,gBACjB,OAAO,KAEX,IAAIqH,EAAYlG,EAAIE,OACpB,KAAOgG,IAAclG,EAAIE,QACrBgG,EAAYlG,EAAIE,QAA0B,EAAhBS,KAAKQ,SAAe,GAAK,EAAAhC,KAAI,OAAOgH,sBAGlE,OADAnG,EAAIE,OAASgG,EACNlG,EAGXoG,qBACI,MAAMpG,EAAM,EAAAb,KAAI,OAAc6B,gBAC9B,KAAMhB,aAAe,EAAAnB,gBACjB,OAAO,KAGX,IAAIqH,EAAYlG,EAAIE,QAAU,EAAAf,KAAI,OAAOmG,uBACzC,KAAOY,IAAclG,EAAIE,QACrBgG,GAAavF,KAAKQ,SAAW+E,EAAY,EAAIA,GAAa,EAAA/G,KAAI,OAAOmG,uBAGzE,OADAtF,EAAIE,OAASgG,EACNlG,EAGXqG,mBACI,MAAMrG,EAAM,EAAAb,KAAI,OAAc6B,gBAC9B,OAAMhB,aAAe,EAAAnB,gBAGhB,EAAAM,KAAI,SAAaa,EAAIG,UACtBH,EAAIG,SAAWH,EAAIG,SAEhBH,GALI,KAsBfsG,OAAOrD,GAAU,GAMb,IAAIsD,EACJ,GANA,EAAApH,KAAI,EAAY8D,EAAO,MAEnB,EAAA9D,KAAI,QAAa,EAAAA,KAAI,OAAOyF,eAC5B,EAAAzF,KAAI,SAAc,KAAlBA,OAGC8D,IAAY,EAAA9D,KAAI,OAAOyF,cAAgB,EAAAzF,KAAI,OAAc8B,OAAS,EAAA9B,KAAI,OAAOkF,GAAI,CAGlF,IAFAkC,EAAO,EAAApH,KAAI,OAAOqH,yBAClBD,EAAOA,EAAO,EAAApH,KAAI,OAAc8B,OAAS,EAAA9B,KAAI,OAAc8B,OAASsF,EAC7DA,EAAO5F,KAAKQ,UACfoF,IACApH,KAAKoG,aAKT,IAFAgB,EAAO,EAAApH,KAAI,OAAOsH,wBAClBF,EAAOA,EAAO,EAAApH,KAAI,OAAOkF,GAAK,EAAAlF,KAAI,OAAOkF,GAAKkC,EACvCA,EAAO5F,KAAKQ,UACfoF,IACApH,KAAK4F,aAKb,IADAwB,EAAO,EAAApH,KAAI,OAAOuH,+BACXH,EAAO5F,KAAKQ,UACfoF,IACApH,KAAKkH,mBAKT,IAFAE,EAAO,EAAApH,KAAI,OAAOwH,iCAClBJ,EAAOA,EAAO,EAAApH,KAAI,OAAc8B,OAAS,EAAA9B,KAAI,OAAc8B,OAASsF,EAC7DA,EAAO5F,KAAKQ,UACfoF,IACApH,KAAKiH,qBAKT,IAFAG,EAAO,EAAApH,KAAI,OAAOyH,gCAClBL,EAAOA,EAAO,EAAApH,KAAI,OAAc8B,OAAS,EAAA9B,KAAI,OAAc8B,OAASsF,EAC7DA,EAAO5F,KAAKQ,UACfoF,IACApH,KAAK8G,sB,iGArDT,IAAIY,EAAY,EAChB,IAAK,IAAIpI,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAc8B,OAAQxC,GAAK,EAAG,CAClD,MAAMgB,EAAI,EAAAN,KAAI,OAAcW,IAAIrB,GAC1BgB,aAAa,EAAAZ,iBACdY,EAAEU,QAKP0G,EAAYpH,EAAES,OAAS2G,EAAYpH,EAAES,OAAS2G,GAJ1C,EAAA1H,KAAI,OAAcuC,OAAOjD,GACzBA,S,yfC5RhB,YACA,YACA,YACA,a,yzBCHA,eAEA,MAAaiB,UAAiB,EAAA2C,KAI1BlE,YAAYe,GACRoD,MAAMpD,GAJV,WAAK,GACL,WAAK,GAMDF,QACA,OAAO,EAAAG,KAAI,OAGXH,MAAEyB,GACF,EAAAtB,KAAI,EAAMsB,EAAK,KAGfkF,QACA,OAAO,EAAAxG,KAAI,OAGXwG,MAAElF,GACF,EAAAtB,KAAI,EAAMsB,EAAK,KAGnBgC,OAAOC,GACH,OAAMA,aAAehD,GACdP,KAAKD,mBAAqBwD,EAAIxD,iBAGzCyD,WACI,OAAOxD,KAAKD,kBA9BpB,a,41BCAA,cAEA,eAQIf,YAAYC,GAPZ,mBACA,WAAS,GACT,WAAS,GACT,YAAa,GACb,mBACA,mBAGI,EAAAe,KAAI,EAAWf,EAAM,KACrB,EAAAe,KAAI,EAAe,KAAI,KACvB,EAAAA,KAAI,EAAY,KAAI,KAGpB2H,gBACA,OAAO,EAAA3H,KAAI,OAGX2H,cAAUrG,GACV,EAAAtB,KAAI,EAAcsB,EAAK,KAGvBrC,aACA,OAAO,EAAAe,KAAI,OAGXf,WAAOqC,GACP,EAAAtB,KAAI,EAAWsB,EAAK,KAGpBsG,YACA,OAAO,EAAA5H,KAAI,OAGX4H,UAAMtG,GACN,EAAAtB,KAAI,EAAUsB,EAAK,KAGnBuB,YACA,OAAO,EAAA7C,KAAI,OAGX6C,UAAMvB,GACN,EAAAtB,KAAI,EAAUsB,EAAK,KAGnBuG,cACA,OAAO,EAAA7H,KAAI,OAGX6H,YAAQvG,GACR,EAAAtB,KAAI,EAAYsB,EAAK,KAGzBwG,qBACI,EAAA9H,KAAI,EAAe,IAAI,EAAA+H,WAAW,EAAA/H,KAAI,QAAS,KAGnDgE,SAASgE,GACL,OAAOhI,KAAKf,OAAO+E,SAASgE,EAAO/I,QAGvCkI,SACQnH,KAAK2H,WAGT3H,KAAKf,OAAOkI,OAAOnH,KAAK4H,MAAQ5H,KAAKf,OAAO8E,iBAGhD9C,UAAUC,G,MAIN,OAHK,EAAAlB,KAAI,QACLA,KAAK8H,sBAEc,QAAhB,IAAA9H,KAAI,cAAY,eAAEiB,UAAUC,KAAU,K,8kBC7ErD,YACA,YACA,a,62BCFA,eACA,SACA,SACA,SAEA,aAuCIlC,YAAYiJ,EAAoBC,EAAqBC,G,YAlCrD,WAAM,GACN,WAAM,GACN,WAAM,IAEN,WAAM,IACN,WAAM,GAEN,WAAyB,GACzB,WAA0B,IAE1B,WAAa,IAEb,WAAmC,GACnC,WAAkC,IAClC,WAAoC,IACpC,WAA2B,KAC3B,WAA4B,KAE5B,WAAqB,MAErB,WAAc,GACd,WAAe,GACf,WAAc,GAEd,WAAgB,GAEhB,WAA0B,IAC1B,WAA2B,IAE3B,WAA+C,IAAI9I,KACnD,WAA2B,IAAI,EAAAuE,eAE/B,YAAgB,GAGZ5D,KAAKiD,MAAMgF,EAAYC,EAAaC,GAvC7BzE,uBACP,OAAOlC,KAAK4G,IAAI,EAAG,IAyCnBvE,wBACA,OAAO,EAAA7D,KAAI,OAGXyF,mBACA,OAAO,EAAAzF,KAAI,OAGXmI,cACA,OAAO,EAAAnI,KAAI,OAGXqI,qBACA,OAAO,EAAArI,KAAI,OAEXsI,eACA,OAAO,EAAAtI,KAAI,OAGXgH,4BACA,OAAO,EAAAhH,KAAI,OAGXmG,6BACA,OAAO,EAAAnG,KAAI,OAGXsH,8BACA,OAAO,EAAAtH,KAAI,OAGXqH,+BACA,OAAO,EAAArH,KAAI,OAGXyH,sCACA,OAAO,EAAAzH,KAAI,OAGXwH,uCACA,OAAO,EAAAxH,KAAI,OAGXuH,qCACA,OAAO,EAAAvH,KAAI,OAGXkF,OAAG5D,GACH,EAAAtB,KAAI,EAAOsB,EAAK,KAGhB4D,SACA,OAAO,EAAAlF,KAAI,OAGXuI,SACA,OAAO,EAAAvI,KAAI,OAGXmF,SACA,OAAO,EAAAnF,KAAI,OAGXoF,SACA,OAAO,EAAApF,KAAI,OAGXqF,SACA,OAAO,EAAArF,KAAI,OAGfiD,MAAMgF,EAAoBC,EAAqBC,GAC3C,EAAAnI,KAAI,EAAeiI,EAAU,KAC7B,EAAAjI,KAAI,EAAgBkI,EAAW,KAC/B,EAAAlI,KAAI,EAAemI,EAAO,KAE1B,EAAAnI,KAAI,OAAiBqC,QACrB,EAAArC,KAAI,OAAWqC,QACf,EAAArC,KAAI,EAAY,GAAE,KAElBA,KAAKkF,GAAkC,GAA5B+C,EAAaC,GAExB,IAAK,IAAI5I,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAcV,GAAK,EAAG,CAC1C,MAAMkJ,EAAqBxI,KAAKuG,UAChCiC,EAAS3I,EAAI,GACb2I,EAAShC,GAAKlH,EAAI,IAAM,EAAAU,KAAI,OAAe,GAG/C,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAeV,GAAK,EAAG,CAC3C,MAAMkJ,EAAqBxI,KAAKuG,UAChCiC,EAAS3I,EAAI,GACb2I,EAAShC,GAAKlH,EAAI,IAAM,EAAAU,KAAI,OAAgB,GAEhD,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAcV,GAAK,EAAG,CAC1C,MAAMgB,EAAY,IAAI,EAAAmI,OAAOzI,KAAKuF,eAClCjF,EAAEwH,qBACF,EAAA9H,KAAI,OAAUC,KAAKK,IAI3BmG,gBAAgBiC,EAAiBC,EAAiBrG,GAC9C,MACMsG,EADiB,IAAI,EAAAlJ,eAAe,EAAGgJ,EAAOC,GACrBtF,aACzBwF,EAAW,EAAA7I,KAAI,OAAiBW,IAAIiI,GAC1C,IAAIC,EAGA,MAAM,IAAI1H,MAAM,oCAFhB0H,EAASzF,aAAed,EAKhC+D,gBAAgBqC,EAAiBC,GAC7B,MACMC,EADiB,IAAI,EAAAlJ,eAAe,EAAGgJ,EAAOC,GACrBtF,aACzBwF,EAAW,EAAA7I,KAAI,OAAiBW,IAAIiI,GAC1C,OAAKC,EACEA,EAASzF,aADM,EAI1BmC,cACI,MAAMtG,EAAiB,IAAI,EAAA6J,OAAO9I,MAClC,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAe,EAAAA,KAAI,OAAeV,GAAK,EAC3DL,EAAOC,MAAM+C,IAAIjC,KAAKuG,QAAQjH,EAAI,IAEtC,OAAOL,EAGXqG,qBAAqBzE,GACjB,MAAMkI,EAAiB,IAAI,EAAArJ,eAAemB,EAAId,iBAAkBc,EAAIL,KAAMK,EAAIJ,IAG9E,OAFAsI,EAAehI,OAASF,EAAIE,OAC5BgI,EAAe/H,QAAUH,EAAIG,QACtB+H,EAGXrD,cAAcgD,EAAiBC,GAC3B,MAAMI,EAAiB,IAAI,EAAArJ,eAAe,EAAGgJ,EAAOC,GAC9CC,EAAUG,EAAe1F,aAC/B,GAAI,EAAArD,KAAI,OAAiBgJ,IAAIJ,GAAU,CACnC,MAAMC,EAAW,EAAA7I,KAAI,OAAiBW,IAAIiI,GAC1CG,EAAehJ,iBAAmB8I,EAAWA,EAAS9I,iBAAmB,OAEzE,EAAAC,KAAI,OAAiBF,IAAI8I,EAASG,GAClCA,EAAehJ,iBAAmB,EAAAC,KAAI,OAAiB8B,KAAO,EAGlE,OAAOiH,EAGXxC,QAAQ0C,GACJ,IAAIT,EACJ,GAAIS,GAAMA,GAAM,EAAAjJ,KAAI,OAAW8B,QAE3B,GADA0G,EAAW,EAAAxI,KAAI,OAAWW,IAAIsI,EAAK,KAC7BT,aAAoB,EAAAjI,UACtB,MAAM,IAAIY,MAAM,uCAGpBqH,EAAW,IAAI,EAAAjI,SAAS,EAAAP,KAAI,OAAW8B,OAAS,GAChD,EAAA9B,KAAI,OAAWiC,IAAIuG,GAEvB,OAAOA,EAGXU,eACI,IAAK,IAAI5J,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C6J,QAAQC,IAAI,EAAApJ,KAAI,OAAUV,GAAGuD,MAAO,EAAA7C,KAAI,OAAUV,GAAGwC,QAI7DuH,OAAO5D,GAAe,G,MAClB,EAAAzF,KAAA,OAAAA,KAAA,YAAoB,KACpB,EAAAA,KAAI,EAAiByF,GAAgB,EAAAzF,KAAI,OAAiB,IAAO,EAAC,KAClE,EAAAA,KAAI,SAAgB,KAApBA,MACA,EAAAA,KAAI,SAAY,KAAhBA,MACA,EAAAA,KAAI,SAAM,KAAVA,MACA,EAAAA,KAAI,SAAe,KAAnBA,MACA,EAAAA,KAAI,SAAW,KAAfA,MACA,EAAAA,KAAI,SAAQ,KAAZA,MACA,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C,EAAAU,KAAI,OAAUV,GAAGwI,uB,6VAKrB,IAAK,IAAIxI,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C,EAAAU,KAAI,OAAUV,GAAG6H,UAExB,aAGG,MAAMmC,EAAW,IAAI,EAAAC,eAAe,EAAAvJ,KAAI,QACxC,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3CgK,EAASrH,IAAI,EAAAjC,KAAI,OAAUV,IAE/B,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAAG,CAC9C,MAAMgB,EAAI,EAAAN,KAAI,OAAUV,GACxB,GAAkB,OAAdgB,EAAEuH,QAAkB,CACpB,MAAM2B,EAAIF,EAAStH,SACnB1B,EAAErB,OAASuK,EAAEC,QACbD,EAAEE,IAAIpJ,GAAG,IAGjBgJ,EAASrG,SACZ,aAGG,IAAK,IAAI3D,EAAI,EAAAU,KAAI,OAAUR,OAAS,EAAGF,GAAK,EAAGA,IACvC,EAAAU,KAAI,OAAUV,GAAGwC,QAAU,IAAM,EAAA9B,KAAI,OAAUV,GAAG6I,QAAQ,GAAGR,YAC7D,EAAA3H,KAAI,OAAUV,GAAGqK,YACjB,EAAA3J,KAAI,OAAUoC,OAAO9C,EAAG,KAGnC,aAGG,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C,EAAAU,KAAI,OAAUV,GAAGsK,KAAK,EAAA5J,KAAI,SAEjC,aAGG,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C,EAAAU,KAAI,OAAUV,GAAG2D,QAErB,IAAK,IAAI3D,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAAG,CAC9C,MAAMgB,EAAI,EAAAN,KAAI,OAAUV,GACxB,GAAkB,OAAdgB,EAAEuH,QACF,SAGJ,IAAIgC,GAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAA9J,KAAI,OAAUR,OAAQsK,GAAK,EAE3C,GADU,EAAA9J,KAAI,OAAU8J,GAClBJ,IAAIpJ,GAAI,CACVuJ,GAAQ,EACR,MAGHA,GACD,EAAA7J,KAAI,OAAUC,KAAK,IAAI,EAAA8J,QAAQzJ,IAGvC,IAAK,IAAIhB,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAC3C,EAAAU,KAAI,OAAUV,GAAG0K,cAAchK,KAAKyF,eAE3C,aAGG,IAAIwE,EAAW,EACf,MAAMC,EAAe,GACrB,IAAIC,EAAWC,EAAAA,EAEf,IAAK,IAAI9K,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAAG,CAC9C,MAAM4G,EAAO,EAAAlG,KAAI,OAAUV,GAC3B4G,EAAKyB,WAAY,EACjBsC,EAAW/D,EAAKrD,MAAQoH,EAAW/D,EAAKrD,MAAQoH,EAChDE,EAAWjE,EAAKrD,MAAQsH,EAAWjE,EAAKrD,MAAQsH,EAGpD,IAAK,IAAI7K,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAAG,CAC9C,MAAM4G,EAAO,EAAAlG,KAAI,OAAUV,GACvB4G,EAAKrD,QAAUoH,GACfC,EAAajK,KAAKX,GAClB4G,EAAKyB,WAAY,EACjBzB,EAAKrD,MAAQ,GACNqD,EAAKrD,QAAUsH,EACtBjE,EAAKrD,MAAQ,EAEbqD,EAAKrD,OAASqD,EAAKrD,MAAQsH,IAAaF,EAAWE,GAIvDD,EAAa1K,OAAS,GACtB0K,EAAajE,SAAQ3G,IACjB,EAAAU,KAAI,OAAUV,GAAGqI,WAAY,KAIrC,MAAM0C,EAAM,EAAArK,KAAI,OAAiB,GAAM,KAEvC,EAAAA,KAAI,OAAUiG,SAAQC,IAClB,MAAMoE,EAAUpE,EAAKjH,OAAOE,YAAY2C,OACxCoE,EAAKrD,OAASrB,KAAK+I,KAAK/I,KAAK+I,KAAKD,IAAYD,O,g0BCvU1D,eAEA,gBAMIrL,YAAYgJ,G,YALZ,WAA0B,IAC1B,mBACA,WAAS,GACT,YAAgB,GAGZ,EAAAhI,KAAI,EAAmBgI,EAAM,KAC7B,EAAAhI,KAAI,OAAiB6H,QAAU7H,KAC/B,EAAAA,KAAI,OAAUC,KAAK+H,GAGnBnF,YACA,OAAO,EAAA7C,KAAI,OAGXmI,cACA,OAAO,EAAAnI,KAAI,OAGf0J,IAAI1B,EAAgBwC,GAAQ,GACxB,SAAIA,GAASxC,EAAOhE,SAAS,EAAAhE,KAAI,QAAoB,EAAAA,KAAI,OAAiBf,OAAO0E,KAAK4E,MAClFP,EAAOH,QAAU7H,KACjB,EAAAA,KAAI,OAAUC,KAAK+H,IACZ,GAKf2B,YACI,IAAK,IAAIrK,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EACjC,EAAAU,KAAI,OAAUV,GACtBuI,QAAU,KAEhB,EAAA7H,KAAI,EAAY,GAAE,KAGtBgK,cAAcvE,GACV,EAAAzF,KAAI,EAAiByF,EAAY,KACjC,IAAInE,EAAQ,EACZ,IAAK,IAAIhC,EAAI,EAAGA,EAAI,EAAAU,KAAI,OAAUR,OAAQF,GAAK,EAE3CgC,GADU,EAAAtB,KAAI,OAAUV,GACbuD,MAEf,EAAA7C,KAAI,EAAUsB,EAAQ,EAAAtB,KAAI,OAAUR,OAAM,KAO9CyD,QACI,EAAAjD,KAAI,EAAmB,EAAAA,KAAI,SAAiB,KAArBA,MAAuB,KAC9CA,KAAK2J,YACL,EAAA3J,KAAI,OAAUC,KAAK,EAAAD,KAAI,QACvB,EAAAA,KAAI,OAAiB6H,QAAU7H,KAC/B,EAAAA,KAAI,EAAU,EAAC,KAGnB4J,KAAKjH,EAAY,IACb,EAAA3C,KAAI,OAAUE,MAAK,CAACC,EAAGC,IACZD,EAAE0C,MAAQzC,EAAEyC,OAAS,EAAI,IAGpC,MAAM4H,EAAQ9H,EAAY,EAAA3C,KAAI,OAAUR,OACxC,IAAK,IAAIF,EAAI,EAAAU,KAAI,OAAUR,OAAS,EAAGF,EAAImL,EAAOnL,GAAK,EAC/C,EAAAU,KAAI,OAAUV,GAAGqI,YAGrB,EAAA3H,KAAI,OAAUV,GAAGuI,QAAU,KAC3B,EAAA7H,KAAI,OAAUoC,OAAO9C,EAAG,IAIhCmK,QACI,MAAMiB,EAAK,EAAA1K,KAAI,SAAiB,KAArBA,MACL2K,EAAK,EAAA3K,KAAI,SAAiB,KAArBA,MACX,OAAI0K,EAAG7H,OAAS8H,EAAG9H,MACR,EAAAiG,OAAO8B,UAAUF,EAAGzL,OAAQ0L,EAAG1L,QAE/B,EAAA6J,OAAO8B,UAAUD,EAAG1L,OAAQyL,EAAGzL,QAI9C6C,OACI,OAAO,EAAA9B,KAAI,OAAUR,S,mFArCrB,OAAO,EAAAQ,KAAI,OAAUwB,KAAKO,MAAMP,KAAKQ,SAAW,EAAAhC,KAAI,OAAUR,YClDlEqL,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAarM,QAGrB,IAAIC,EAASiM,EAAyBE,GAAY,CAGjDpM,QAAS,IAOV,OAHAuM,EAAoBH,GAAUI,KAAKvM,EAAOD,QAASC,EAAQA,EAAOD,QAASmM,GAGpElM,EAAOD,Q,4FCrBf,aAAS,sEAAA8E,S","sources":["webpack://NeatJS/webpack/universalModuleDefinition","webpack://NeatJS/./src/calculations/Calculator.ts","webpack://NeatJS/./src/calculations/Connection.ts","webpack://NeatJS/./src/calculations/Node.ts","webpack://NeatJS/./src/calculations/index.ts","webpack://NeatJS/./src/dataStructures/index.ts","webpack://NeatJS/./src/dataStructures/randomHashSet.ts","webpack://NeatJS/./src/dataStructures/randomSelector.ts","webpack://NeatJS/./src/genome/connectionGene.ts","webpack://NeatJS/./src/genome/gene.ts","webpack://NeatJS/./src/genome/genome.ts","webpack://NeatJS/./src/genome/index.ts","webpack://NeatJS/./src/genome/nodeGene.ts","webpack://NeatJS/./src/neat/client.ts","webpack://NeatJS/./src/neat/index.ts","webpack://NeatJS/./src/neat/neat.ts","webpack://NeatJS/./src/neat/species.ts","webpack://NeatJS/webpack/bootstrap","webpack://NeatJS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NeatJS\"] = factory();\n\telse\n\t\troot[\"NeatJS\"] = factory();\n})(self, () => {\nreturn ","import { ConnectionGene, Genome, NodeGene } from '../genome';\nimport { Node } from './Node';\nimport { Connection } from './Connection';\n\nexport class Calculator {\n    #inputNodes: Array<Node> = [];\n    #hiddenNodes: Array<Node> = [];\n    #outputNodes: Array<Node> = [];\n\n    constructor(genome: Genome) {\n        const nodes = genome.nodes;\n        const connections = genome.connections;\n\n        const nodeHashmap: Map<number, Node> = new Map();\n\n        for (let i = 0; i < nodes.data.length; i += 1) {\n            const n = nodes.data[i];\n            if (n instanceof ConnectionGene) continue;\n            const node: Node = new Node(n.x);\n            nodeHashmap.set(n.innovationNumber, node);\n\n            if (n.x <= 0.1) {\n                this.#inputNodes.push(node);\n            } else if (n.x >= 0.9) {\n                this.#outputNodes.push(node);\n            } else {\n                this.#hiddenNodes.push(node);\n            }\n        }\n        this.#hiddenNodes.sort((a, b) => {\n            return a.compereTo(b);\n        });\n\n        for (let i = 0; i < connections.data.length; i += 1) {\n            const c = connections.data[i];\n            if (c instanceof NodeGene) continue;\n\n            const from: NodeGene = c.from;\n            const to: NodeGene = c.to;\n\n            const nodeFrom = nodeHashmap.get(from.innovationNumber);\n            const nodeTo = nodeHashmap.get(to.innovationNumber);\n            if (!nodeFrom || !nodeTo) continue;\n\n            const con = new Connection(nodeFrom, nodeTo);\n            con.weight = c.weight;\n            con.enabled = c.enabled;\n\n            nodeTo.connections.push(con);\n        }\n    }\n\n    calculate(input: Array<number>): Array<number> {\n        if (input.length !== this.#inputNodes.length) throw new Error('Data dosent fit');\n        for (let i = 0; i < this.#inputNodes.length; i++) {\n            this.#inputNodes[i].output = input[i];\n        }\n        for (let i = 0; i < this.#hiddenNodes.length; i++) {\n            this.#hiddenNodes[i].calculate();\n        }\n        const output = new Array<number>(this.#outputNodes.length);\n        for (let i = 0; i < this.#outputNodes.length; i++) {\n            this.#outputNodes[i].calculate();\n            output[i] = this.#outputNodes[i].output;\n        }\n        return output;\n    }\n}\n","import { Node } from './Node';\n\nexport class Connection {\n    #from: Node;\n    #to: Node;\n    #weight = 0;\n    #enabled = true;\n\n    constructor(from: Node, to: Node) {\n        this.#from = from;\n        this.#to = to;\n    }\n\n    get from(): Node {\n        return this.#from;\n    }\n\n    set from(value: Node) {\n        this.#from = value;\n    }\n\n    get to(): Node {\n        return this.#to;\n    }\n\n    set to(value: Node) {\n        this.#to = value;\n    }\n\n    get weight(): number {\n        return this.#weight;\n    }\n\n    set weight(value: number) {\n        this.#weight = value;\n    }\n\n    get enabled(): boolean {\n        return this.#enabled;\n    }\n\n    set enabled(value: boolean) {\n        this.#enabled = value;\n    }\n}\n","import { Connection } from './Connection';\n\nexport class Node {\n    #x: number;\n    #output = 0;\n    #connections: Array<Connection> = [];\n\n    constructor(x: number) {\n        this.#x = x;\n    }\n\n    get x(): number {\n        return this.#x;\n    }\n\n    set x(value: number) {\n        this.#x = value;\n    }\n\n    get output(): number {\n        return this.#output;\n    }\n\n    set output(value: number) {\n        this.#output = value;\n    }\n\n    get connections(): Array<Connection> {\n        return this.#connections;\n    }\n\n    set connections(value: Array<Connection>) {\n        this.#connections = value;\n    }\n\n    #activation(sum: number): number {\n        return 1 / (1 + Math.exp(-sum));\n    }\n\n    calculate() {\n        let sum = 0;\n        for (let i = 0; i < this.#connections.length; i += 1) {\n            const c = this.#connections[i];\n            if (c.enabled) {\n                sum += c.weight * c.from.output;\n            }\n        }\n        this.#output = this.#activation(sum);\n    }\n\n    compereTo(node: Node): number {\n        if (this.x > node.x) {\n            return 1;\n        } else if (this.x < node.x) {\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n}\n","export * from './Node';\nexport * from './Connection';\nexport * from './Calculator';\n","export * from './randomHashSet';\nexport * from './randomSelector';\n","import { ConnectionGene, NodeGene } from '../genome';\n\nexport class RandomHashSet {\n    #set: Set<NodeGene | ConnectionGene>;\n    #data: Array<NodeGene | ConnectionGene>;\n\n    constructor() {\n        this.#set = new Set();\n        this.#data = [];\n    }\n\n    contains(gene: NodeGene | ConnectionGene): boolean {\n        let contains = false;\n        for (let i = 0; i < this.data.length; i += 1) {\n            if (this.data[i].innovationNumber === gene.innovationNumber) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n\n    randomElement(): NodeGene | ConnectionGene | null {\n        if (!this.#set.size) {\n            return null;\n        }\n        return this.#data[Math.floor(this.#data.length * Math.random())];\n    }\n\n    add(gene: NodeGene | ConnectionGene) {\n        if (!this.contains(gene)) {\n            this.#set.add(gene);\n            this.#data.push(gene);\n        }\n    }\n\n    addSorted(gene: NodeGene | ConnectionGene) {\n        if (!this.contains(gene)) {\n            for (let i = 0; i < this.size(); i++) {\n                const innovation = this.get(i).innovationNumber;\n                if (gene.innovationNumber < innovation) {\n                    this.#data.splice(i, 0, gene);\n                    this.#set.add(gene);\n                    return;\n                }\n            }\n            this.#set.add(gene);\n            this.#data.push(gene);\n        }\n    }\n\n    size(): number {\n        return this.#data.length;\n    }\n\n    clear() {\n        this.#set.clear();\n        this.#data = [];\n    }\n\n    get(index: number): NodeGene | ConnectionGene {\n        return this.#data[index];\n    }\n\n    remove(arg: number | ConnectionGene) {\n        if (arg instanceof ConnectionGene) {\n            const index = this.#data.indexOf(arg);\n            this.#data.splice(index, 1);\n            this.#set.delete(arg);\n        } else {\n            if (arg < 0 || arg >= this.#set.size) {\n                return;\n            }\n            this.#set.delete(this.#data[arg]);\n            this.#data.splice(arg, 1);\n        }\n    }\n\n    get data(): Array<NodeGene | ConnectionGene> {\n        return this.#data;\n    }\n}\n","import { Species } from '../neat';\n\nexport class RandomSelector {\n    #objects: Array<Species> = [];\n    #survivors: number;\n    #totalScore = 0;\n\n    constructor(survivors: number) {\n        this.#survivors = survivors;\n    }\n\n    add(object: Species) {\n        this.#objects.push(object);\n        this.#totalScore += object.score;\n        this.#objects.sort((a, b) => {\n            return a.score > b.score ? -1 : 1;\n        });\n    }\n\n    random(): Species {\n        const randomScore = Math.abs(Math.random() * this.#totalScore * this.#survivors);\n        let scoreIndex = 0;\n        for (let i = 0; i < this.#objects.length; i++) {\n            scoreIndex += Math.abs(this.#objects[i].score);\n            if (scoreIndex >= randomScore) {\n                return this.#objects[i];\n            }\n        }\n        throw new Error('random Species not found');\n    }\n\n    reset() {\n        this.#objects = [];\n        this.#totalScore = 0;\n    }\n}\n","import { Gene } from './gene';\nimport { NodeGene } from './nodeGene';\nimport { Neat } from '../neat';\n\nexport class ConnectionGene extends Gene {\n    #from: NodeGene;\n    #to: NodeGene;\n    #weight = 0;\n    #enabled = true;\n\n    #replaceIndex = 0;\n\n    constructor(innovationNumber: number, from: NodeGene, to: NodeGene) {\n        super(innovationNumber);\n        this.#from = from;\n        this.#to = to;\n    }\n\n    get replaceIndex(): number {\n        return this.#replaceIndex;\n    }\n\n    set replaceIndex(value: number) {\n        this.#replaceIndex = value;\n    }\n\n    get from(): NodeGene {\n        return this.#from;\n    }\n\n    set from(value: NodeGene) {\n        this.#from = value;\n    }\n\n    get to(): NodeGene {\n        return this.#to;\n    }\n\n    set to(value: NodeGene) {\n        this.#to = value;\n    }\n\n    get weight(): number {\n        return this.#weight;\n    }\n\n    set weight(value: number) {\n        this.#weight = value;\n    }\n\n    get enabled(): boolean {\n        return this.#enabled;\n    }\n\n    set enabled(value: boolean) {\n        this.#enabled = value;\n    }\n\n    getHashKey(): string {\n        return `${this.from.innovationNumber}-${this.from.x}-${this.to.innovationNumber}-${this.to.x}`;\n    }\n\n    equals(obj: unknown): boolean {\n        if (!(obj instanceof ConnectionGene)) return false;\n\n        return this.from.equals(obj.from) && this.to.equals(obj.to);\n    }\n\n    hashCode(): number {\n        return this.from.innovationNumber * Neat.MAX_NODES + this.to.innovationNumber;\n    }\n}\n","export class Gene {\n    #innovationNumber: number;\n\n    constructor(innovationNumber: number) {\n        this.#innovationNumber = innovationNumber;\n    }\n\n    get innovationNumber(): number {\n        return this.#innovationNumber;\n    }\n\n    set innovationNumber(value: number) {\n        this.#innovationNumber = value;\n    }\n}\n","import { RandomHashSet } from '../dataStructures';\nimport { Neat } from '../neat';\nimport { ConnectionGene } from './connectionGene';\nimport { NodeGene } from './nodeGene';\n\nexport class Genome {\n    #connections: RandomHashSet = new RandomHashSet();\n    #nodes: RandomHashSet = new RandomHashSet();\n    #neat: Neat;\n    #optErrTrashhold: number;\n    #selfOpt = false;\n\n    constructor(neat: Neat) {\n        this.#neat = neat;\n        this.#optErrTrashhold = neat.OPT_ERR_TRASHHOLD;\n    }\n\n    get selfOpt(): boolean {\n        return this.#selfOpt;\n    }\n\n    get optErrTrashhold(): number {\n        return this.#optErrTrashhold;\n    }\n\n    get connections(): RandomHashSet {\n        return this.#connections;\n    }\n\n    get nodes(): RandomHashSet {\n        return this.#nodes;\n    }\n\n    get neat(): Neat {\n        return this.#neat;\n    }\n\n    distance(g2: Genome): number {\n        let g1: Genome = this;\n\n        const higGene1: ConnectionGene | NodeGene = g1.connections.get(g1.connections.size() - 1);\n        const higGene2: ConnectionGene | NodeGene = g2.connections.get(g2.connections.size() - 1);\n\n        const higInnovationG1 = higGene1 instanceof ConnectionGene ? higGene1.innovationNumber : 0;\n        const higInnovationG2 = higGene2 instanceof ConnectionGene ? higGene2.innovationNumber : 0;\n        if (higInnovationG1 < higInnovationG2) {\n            const tempG = g1;\n            g1 = g2;\n            g2 = tempG;\n        }\n\n        let indexG1 = 0;\n        let indexG2 = 0;\n\n        let disjoint = 0;\n        let weightDiff = 0;\n        let similar = 0;\n        while (indexG1 < g1.connections.size() && indexG2 < g2.connections.size()) {\n            const gene1: ConnectionGene | NodeGene = g1.connections.get(indexG1);\n            const gene2: ConnectionGene | NodeGene = g2.connections.get(indexG2);\n            if (!(gene1 instanceof ConnectionGene) || !(gene2 instanceof ConnectionGene)) {\n                throw new Error('gene is not a ConnectionGene');\n            }\n            const inn1: number = gene1.innovationNumber;\n            const inn2: number = gene2.innovationNumber;\n\n            if (inn1 > inn2) {\n                indexG2++;\n                disjoint++;\n            } else if (inn1 < inn2) {\n                indexG1++;\n                disjoint++;\n            } else {\n                indexG1++;\n                indexG2++;\n                similar++;\n                weightDiff += Math.abs(gene1.weight - gene2.weight);\n            }\n        }\n\n        weightDiff /= similar || 1;\n\n        const excess = g1.connections.size() - indexG1;\n        let N = Math.max(g1.connections.size(), g2.connections.size());\n        N = N < this.#neat.CT ? 1 : N;\n\n        return (this.#neat.C1 * excess) / N + (this.#neat.C2 * disjoint) / N + this.#neat.C3 * weightDiff;\n    }\n\n    static crossOver(g1: Genome, g2: Genome): Genome {\n        const genome: Genome = g1.neat.emptyGenome();\n\n        let indexG1 = 0;\n        let indexG2 = 0;\n\n        while (indexG1 < g1.connections.size() && indexG2 < g2.connections.size()) {\n            const gene1 = g1.connections.get(indexG1);\n            const gene2 = g2.connections.get(indexG2);\n            if (!(gene1 instanceof ConnectionGene) || !(gene2 instanceof ConnectionGene)) {\n                throw new Error('gene is not a ConnectionGene');\n            }\n            const inn1: number = gene1.innovationNumber;\n            const inn2: number = gene2.innovationNumber;\n            let addedCon: ConnectionGene | null = null;\n            if (inn1 > inn2) {\n                indexG2++;\n            } else if (inn1 < inn2) {\n                if (!g1.selfOpt || !genome.neat.optimization || gene1.enabled) {\n                    addedCon = Neat.getConnection(gene1);\n                }\n                indexG1++;\n            } else {\n                if ((!g1.selfOpt && !g2.selfOpt) || !genome.neat.optimization || (gene1.enabled && gene2.enabled)) {\n                    if (Math.random() > 0.4) {\n                        addedCon = Neat.getConnection(gene1);\n                    } else {\n                        addedCon = Neat.getConnection(gene2);\n                    }\n                }\n                indexG1++;\n                indexG2++;\n            }\n            if (!(addedCon instanceof ConnectionGene)) {\n                continue;\n            }\n            genome.connections.addSorted(addedCon);\n        }\n        while (indexG1 < g1.connections.size()) {\n            const gene1 = g1.connections.get(indexG1);\n            if (!(gene1 instanceof ConnectionGene)) {\n                throw new Error('gene is not a ConnectionGene');\n            }\n\n            if (!g1.neat.optimization || gene1.enabled) {\n                genome.connections.addSorted(Neat.getConnection(gene1));\n            }\n            indexG1++;\n        }\n        for (let i = 0; i < genome.connections.data.length; i++) {\n            const conn = genome.connections.get(i);\n            if (!(conn instanceof ConnectionGene)) {\n                throw new Error('gene is not a ConnectionGene');\n            }\n            genome.nodes.add(conn.from);\n            genome.nodes.add(conn.to);\n        }\n\n        return genome;\n    }\n\n    mutateLink(): ConnectionGene | null {\n        let geneA = this.#nodes.randomElement();\n        let geneB = this.#nodes.randomElement();\n\n        if (!(geneA instanceof NodeGene) || !(geneB instanceof NodeGene)) {\n            return null;\n        }\n\n        while (geneB instanceof NodeGene && geneA.x === geneB.x) {\n            geneB = this.#nodes.randomElement();\n        }\n\n        if (!(geneB instanceof NodeGene)) {\n            return null;\n        }\n\n        if (geneA.x > geneB.x) {\n            const temp = geneA;\n            geneA = geneB;\n            geneB = temp;\n        }\n        let exists = false;\n        this.#connections.data.forEach(item => {\n            if (item instanceof NodeGene) return;\n            if (item.from === geneA && item.to === geneB) {\n                exists = true;\n            }\n        });\n        if (exists) {\n            return null;\n        }\n\n        const con: ConnectionGene = this.#neat.getConnection(geneA, geneB);\n        con.weight = (Math.random() * 2 - 1) * this.#neat.WEIGHT_RANDOM_STRENGTH;\n\n        this.#connections.addSorted(con);\n        return con;\n    }\n\n    mutateNode(): NodeGene | null {\n        const con = this.#connections.randomElement();\n        if (!(con instanceof ConnectionGene)) {\n            return null;\n        }\n\n        const from: NodeGene = con.from;\n        const to: NodeGene = con.to;\n        const replaceIndex = this.#neat.getReplaceIndex(from, to);\n        let middle: NodeGene;\n        if (replaceIndex === 0) {\n            middle = this.#neat.getNode();\n            middle.x = (from.x + to.x) / 2;\n            middle.y = (from.y + to.y) / 2 + Math.random() * 0.6 - 0.3;\n            middle.y = middle.y < 0.1 ? 0.1 : middle.y > 0.9 ? 0.9 : middle.y;\n            this.#neat.setReplaceIndex(from, to, middle.innovationNumber);\n        } else {\n            middle = this.#neat.getNode(replaceIndex);\n        }\n\n        const con1: ConnectionGene = this.#neat.getConnection(from, middle);\n        const con2: ConnectionGene = this.#neat.getConnection(middle, to);\n        let exists1 = false;\n        let exists2 = false;\n        this.#connections.data.forEach(item => {\n            if (item instanceof NodeGene) return;\n            if (item.from === from && item.to === middle) {\n                exists1 = true;\n            }\n            if (item.from === middle && item.to === to) {\n                exists2 = true;\n            }\n        });\n        if (!exists1) {\n            con1.weight = 1;\n            con2.weight = con.weight;\n            this.#connections.addSorted(con1);\n        }\n        if (!exists2) {\n            con2.enabled = con.enabled;\n            this.#connections.addSorted(con2);\n        }\n        if (!exists1 || !exists2) {\n            con.enabled = false;\n        }\n\n        this.#nodes.add(middle);\n        return middle;\n    }\n\n    mutateWeightShift(): ConnectionGene | null {\n        const con = this.#connections.randomElement();\n        if (!(con instanceof ConnectionGene)) {\n            return null;\n        }\n        let newWeight = con.weight;\n        while (newWeight === con.weight) {\n            newWeight = con.weight + (Math.random() * 2 - 1) * this.#neat.WEIGHT_SHIFT_STRENGTH;\n        }\n        con.weight = newWeight;\n        return con;\n    }\n\n    mutateWeightRandom(): ConnectionGene | null {\n        const con = this.#connections.randomElement();\n        if (!(con instanceof ConnectionGene)) {\n            return null;\n        }\n\n        let newWeight = con.weight || this.#neat.WEIGHT_RANDOM_STRENGTH;\n        while (newWeight === con.weight) {\n            newWeight = (Math.random() * newWeight * 2 - newWeight) * this.#neat.WEIGHT_RANDOM_STRENGTH;\n        }\n        con.weight = newWeight;\n        return con;\n    }\n\n    mutateLinkToggle(): ConnectionGene | null {\n        const con = this.#connections.randomElement();\n        if (!(con instanceof ConnectionGene)) {\n            return null;\n        }\n        if (!this.#selfOpt || con.enabled) {\n            con.enabled = !con.enabled;\n        }\n        return con;\n    }\n\n    #optimization() {\n        let maxWeight = 0;\n        for (let i = 0; i < this.#connections.size(); i += 1) {\n            const c = this.#connections.get(i);\n            if (!(c instanceof ConnectionGene)) continue;\n            if (!c.enabled) {\n                this.#connections.remove(i);\n                i--;\n                continue;\n            }\n            maxWeight = c.weight > maxWeight ? c.weight : maxWeight;\n        }\n    }\n\n    mutate(selfOpt = false) {\n        this.#selfOpt = selfOpt;\n\n        if (this.#selfOpt || this.#neat.optimization) {\n            this.#optimization();\n        }\n        let prob: number;\n        if (!selfOpt || !this.#neat.optimization || this.#connections.size() < this.#neat.CT) {\n            prob = this.#neat.PROBABILITY_MUTATE_NODES;\n            prob = prob > this.#connections.size() ? this.#connections.size() : prob;\n            while (prob > Math.random()) {\n                prob--;\n                this.mutateNode();\n            }\n\n            prob = this.#neat.PROBABILITY_MUTATE_LINK;\n            prob = prob < this.#neat.CT ? this.#neat.CT : prob;\n            while (prob > Math.random()) {\n                prob--;\n                this.mutateLink();\n            }\n        }\n\n        prob = this.#neat.PROBABILITY_MUTATE_TOGGLE_LINK;\n        while (prob > Math.random()) {\n            prob--;\n            this.mutateLinkToggle();\n        }\n\n        prob = this.#neat.PROBABILITY_MUTATE_WEIGHT_RANDOM;\n        prob = prob > this.#connections.size() ? this.#connections.size() : prob;\n        while (prob > Math.random()) {\n            prob--;\n            this.mutateWeightRandom();\n        }\n\n        prob = this.#neat.PROBABILITY_MUTATE_WEIGHT_SHIFT;\n        prob = prob > this.#connections.size() ? this.#connections.size() : prob;\n        while (prob > Math.random()) {\n            prob--;\n            this.mutateWeightShift();\n        }\n    }\n}\n","export * from './gene';\nexport * from './nodeGene';\nexport * from './connectionGene';\nexport * from './genome';\n","import { Gene } from './gene';\n\nexport class NodeGene extends Gene {\n    #x = 0;\n    #y = 0;\n\n    constructor(innovationNumber: number) {\n        super(innovationNumber);\n    }\n\n    get x(): number {\n        return this.#x;\n    }\n\n    set x(value: number) {\n        this.#x = value;\n    }\n\n    get y(): number {\n        return this.#y;\n    }\n\n    set y(value: number) {\n        this.#y = value;\n    }\n\n    equals(obj: unknown): boolean {\n        if (!(obj instanceof NodeGene)) return false;\n        return this.innovationNumber === obj.innovationNumber;\n    }\n\n    hashCode(): number {\n        return this.innovationNumber;\n    }\n}\n","import { Genome } from '../genome';\nimport { Species } from './species';\nimport { Calculator } from '../calculations';\n\nexport class Client {\n    #genome: Genome;\n    #score = 0;\n    #error = 0;\n    #bestScore = false;\n    #species: Species | null;\n    #calculator: Calculator | null;\n\n    constructor(genome: Genome) {\n        this.#genome = genome;\n        this.#calculator = null;\n        this.#species = null;\n    }\n\n    get bestScore(): boolean {\n        return this.#bestScore;\n    }\n\n    set bestScore(value: boolean) {\n        this.#bestScore = value;\n    }\n\n    get genome(): Genome {\n        return this.#genome;\n    }\n\n    set genome(value: Genome) {\n        this.#genome = value;\n    }\n\n    get error(): number {\n        return this.#error;\n    }\n\n    set error(value: number) {\n        this.#error = value;\n    }\n\n    get score(): number {\n        return this.#score;\n    }\n\n    set score(value: number) {\n        this.#score = value;\n    }\n\n    get species(): Species | null {\n        return this.#species;\n    }\n\n    set species(value: Species | null) {\n        this.#species = value;\n    }\n\n    generateCalculator() {\n        this.#calculator = new Calculator(this.#genome);\n    }\n\n    distance(client: Client): number {\n        return this.genome.distance(client.genome);\n    }\n\n    mutate() {\n        if (this.bestScore) {\n            return;\n        }\n        this.genome.mutate(this.error < this.genome.optErrTrashhold);\n    }\n\n    calculate(input: Array<number>): Array<number> {\n        if (!this.#calculator) {\n            this.generateCalculator();\n        }\n        return this.#calculator?.calculate(input) || [];\n    }\n}\n","export * from './neat';\nexport * from './species';\nexport * from './client';\n","import { ConnectionGene, Genome, NodeGene } from '../genome';\nimport { RandomHashSet, RandomSelector } from '../dataStructures';\nimport { Client } from './client';\nimport { Species } from './species';\n\nexport class Neat {\n    static get MAX_NODES(): number {\n        return Math.pow(2, 20);\n    }\n\n    #C1 = 1;\n    #C2 = 1;\n    #C3 = 0.1;\n\n    #CP = 10;\n    #CT = 1;\n\n    #WEIGHT_SHIFT_STRENGTH = 5;\n    #WEIGHT_RANDOM_STRENGTH = 10;\n\n    #SURVIVORS = 0.8;\n\n    #PROBABILITY_MUTATE_WEIGHT_SHIFT = 4;\n    #PROBABILITY_MUTATE_TOGGLE_LINK = 0.5;\n    #PROBABILITY_MUTATE_WEIGHT_RANDOM = 0.2;\n    #PROBABILITY_MUTATE_LINK = 0.05;\n    #PROBABILITY_MUTATE_NODES = 0.05;\n\n    #OPT_ERR_TRASHHOLD = 0.005;\n\n    #inputNodes = 0;\n    #outputNodes = 0;\n    #maxClients = 0;\n\n    #evolveCounts = 0;\n\n    #clients: Array<Client> = [];\n    #species: Array<Species> = [];\n\n    #allConnections: Map<string, ConnectionGene> = new Map<string, ConnectionGene>();\n    #allNodes: RandomHashSet = new RandomHashSet();\n\n    #optimization = false;\n\n    constructor(inputNodes: number, outputNodes: number, clients: number) {\n        this.reset(inputNodes, outputNodes, clients);\n    }\n\n    get OPT_ERR_TRASHHOLD(): number {\n        return this.#OPT_ERR_TRASHHOLD;\n    }\n\n    get optimization(): boolean {\n        return this.#optimization;\n    }\n\n    get clients(): Array<Client> {\n        return this.#clients;\n    }\n\n    get allConnections(): Map<string, ConnectionGene> {\n        return this.#allConnections;\n    }\n    get allNodes(): RandomHashSet {\n        return this.#allNodes;\n    }\n\n    get WEIGHT_SHIFT_STRENGTH(): number {\n        return this.#WEIGHT_SHIFT_STRENGTH;\n    }\n\n    get WEIGHT_RANDOM_STRENGTH(): number {\n        return this.#WEIGHT_RANDOM_STRENGTH;\n    }\n\n    get PROBABILITY_MUTATE_LINK(): number {\n        return this.#PROBABILITY_MUTATE_LINK;\n    }\n\n    get PROBABILITY_MUTATE_NODES(): number {\n        return this.#PROBABILITY_MUTATE_NODES;\n    }\n\n    get PROBABILITY_MUTATE_WEIGHT_SHIFT(): number {\n        return this.#PROBABILITY_MUTATE_WEIGHT_SHIFT;\n    }\n\n    get PROBABILITY_MUTATE_WEIGHT_RANDOM(): number {\n        return this.#PROBABILITY_MUTATE_WEIGHT_RANDOM;\n    }\n\n    get PROBABILITY_MUTATE_TOGGLE_LINK(): number {\n        return this.#PROBABILITY_MUTATE_TOGGLE_LINK;\n    }\n\n    set CT(value: number) {\n        this.#CT = value;\n    }\n\n    get CT(): number {\n        return this.#CT;\n    }\n\n    get CP(): number {\n        return this.#CP;\n    }\n\n    get C1(): number {\n        return this.#C1;\n    }\n\n    get C2(): number {\n        return this.#C2;\n    }\n\n    get C3(): number {\n        return this.#C3;\n    }\n\n    reset(inputNodes: number, outputNodes: number, clients: number) {\n        this.#inputNodes = inputNodes;\n        this.#outputNodes = outputNodes;\n        this.#maxClients = clients;\n\n        this.#allConnections.clear();\n        this.#allNodes.clear();\n        this.#clients = [];\n\n        this.CT = (inputNodes + outputNodes) * 3;\n\n        for (let i = 0; i < this.#inputNodes; i += 1) {\n            const nodeGene: NodeGene = this.getNode();\n            nodeGene.x = 0.1;\n            nodeGene.y = (i + 1) / (this.#inputNodes + 1);\n        }\n\n        for (let i = 0; i < this.#outputNodes; i += 1) {\n            const nodeGene: NodeGene = this.getNode();\n            nodeGene.x = 0.9;\n            nodeGene.y = (i + 1) / (this.#outputNodes + 1);\n        }\n        for (let i = 0; i < this.#maxClients; i += 1) {\n            const c: Client = new Client(this.emptyGenome());\n            c.generateCalculator();\n            this.#clients.push(c);\n        }\n    }\n\n    setReplaceIndex(node1: NodeGene, node2: NodeGene, index: number) {\n        const connectionGene = new ConnectionGene(0, node1, node2);\n        const hashKey = connectionGene.getHashKey();\n        const foundCon = this.#allConnections.get(hashKey);\n        if (foundCon) {\n            foundCon.replaceIndex = index;\n        } else {\n            throw new Error('setReplaceIndex to no connection');\n        }\n    }\n    getReplaceIndex(node1: NodeGene, node2: NodeGene): number {\n        const connectionGene = new ConnectionGene(0, node1, node2);\n        const hashKey = connectionGene.getHashKey();\n        const foundCon = this.#allConnections.get(hashKey);\n        if (!foundCon) return 0;\n        return foundCon.replaceIndex;\n    }\n\n    emptyGenome(): Genome {\n        const genome: Genome = new Genome(this);\n        for (let i = 0; i < this.#inputNodes + this.#outputNodes; i += 1) {\n            genome.nodes.add(this.getNode(i + 1));\n        }\n        return genome;\n    }\n\n    static getConnection(con: ConnectionGene): ConnectionGene {\n        const connectionGene = new ConnectionGene(con.innovationNumber, con.from, con.to);\n        connectionGene.weight = con.weight;\n        connectionGene.enabled = con.enabled;\n        return connectionGene;\n    }\n\n    getConnection(node1: NodeGene, node2: NodeGene): ConnectionGene {\n        const connectionGene = new ConnectionGene(0, node1, node2);\n        const hashKey = connectionGene.getHashKey();\n        if (this.#allConnections.has(hashKey)) {\n            const foundCon = this.#allConnections.get(hashKey);\n            connectionGene.innovationNumber = foundCon ? foundCon.innovationNumber : 0;\n        } else {\n            this.#allConnections.set(hashKey, connectionGene);\n            connectionGene.innovationNumber = this.#allConnections.size + 1;\n        }\n\n        return connectionGene;\n    }\n\n    getNode(id?: number): NodeGene {\n        let nodeGene;\n        if (id && id <= this.#allNodes.size()) {\n            nodeGene = this.#allNodes.get(id - 1);\n            if (!(nodeGene instanceof NodeGene)) {\n                throw new Error('getNode returns not a NodeGene');\n            }\n        } else {\n            nodeGene = new NodeGene(this.#allNodes.size() + 1);\n            this.#allNodes.add(nodeGene);\n        }\n        return nodeGene;\n    }\n\n    printSpecies() {\n        for (let i = 0; i < this.#species.length; i += 1) {\n            console.log(this.#species[i].score, this.#species[i].size());\n        }\n    }\n\n    evolve(optimization = false) {\n        this.#evolveCounts++;\n        this.#optimization = optimization || this.#evolveCounts % 50 === 0;\n        this.#normalizeScore();\n        this.#genSpecies();\n        this.#kill();\n        this.#removeExtinct();\n        this.#reproduce();\n        this.#mutate();\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            this.#clients[i].generateCalculator();\n        }\n    }\n\n    #mutate() {\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            this.#clients[i].mutate();\n        }\n    }\n\n    #reproduce() {\n        const selector = new RandomSelector(this.#SURVIVORS);\n        for (let i = 0; i < this.#species.length; i += 1) {\n            selector.add(this.#species[i]);\n        }\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const c = this.#clients[i];\n            if (c.species === null) {\n                const s = selector.random();\n                c.genome = s.breed();\n                s.put(c, true);\n            }\n        }\n        selector.reset();\n    }\n\n    #removeExtinct() {\n        for (let i = this.#species.length - 1; i >= 0; i--) {\n            if (this.#species[i].size() <= 1 && !this.#species[i].clients[0].bestScore) {\n                this.#species[i].goExtinct();\n                this.#species.splice(i, 1);\n            }\n        }\n    }\n\n    #kill() {\n        for (let i = 0; i < this.#species.length; i += 1) {\n            this.#species[i].kill(this.#SURVIVORS);\n        }\n    }\n\n    #genSpecies() {\n        for (let i = 0; i < this.#species.length; i += 1) {\n            this.#species[i].reset();\n        }\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const c = this.#clients[i];\n            if (c.species !== null) {\n                continue;\n            }\n\n            let found = false;\n            for (let k = 0; k < this.#species.length; k += 1) {\n                const s = this.#species[k];\n                if (s.put(c)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                this.#species.push(new Species(c));\n            }\n        }\n        for (let i = 0; i < this.#species.length; i += 1) {\n            this.#species[i].evaluateScore(this.optimization);\n        }\n    }\n\n    #normalizeScore() {\n        let maxScore = 0;\n        const bestScoreSet = [];\n        let minScore = Infinity;\n\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const item = this.#clients[i];\n            item.bestScore = false;\n            maxScore = item.score > maxScore ? item.score : maxScore;\n            minScore = item.score < minScore ? item.score : minScore;\n        }\n\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const item = this.#clients[i];\n            if (item.score === maxScore) {\n                bestScoreSet.push(i);\n                item.bestScore = true;\n                item.score = 1;\n            } else if (item.score === minScore) {\n                item.score = 0;\n            } else {\n                item.score = (item.score - minScore) / (maxScore - minScore);\n            }\n        }\n\n        if (bestScoreSet.length > 1) {\n            bestScoreSet.forEach(i => {\n                this.#clients[i].bestScore = false;\n            });\n        }\n\n        const cof = this.#optimization ? 0.1 : 0.0001;\n\n        this.#clients.forEach(item => {\n            const allCons = item.genome.connections.size();\n            item.score -= Math.sqrt(Math.sqrt(allCons)) * cof;\n        });\n    }\n}\n","import { Client } from './client';\nimport { Genome } from '../genome';\n\nexport class Species {\n    #clients: Array<Client> = [];\n    #representative: Client;\n    #score = 0;\n    #optimization = false;\n\n    constructor(client: Client) {\n        this.#representative = client;\n        this.#representative.species = this;\n        this.#clients.push(client);\n    }\n\n    get score(): number {\n        return this.#score;\n    }\n\n    get clients(): Array<Client> {\n        return this.#clients;\n    }\n\n    put(client: Client, force = false): boolean {\n        if (force || client.distance(this.#representative) < this.#representative.genome.neat.CP) {\n            client.species = this;\n            this.#clients.push(client);\n            return true;\n        }\n        return false;\n    }\n\n    goExtinct() {\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const c = this.#clients[i];\n            c.species = null;\n        }\n        this.#clients = [];\n    }\n\n    evaluateScore(optimization: boolean) {\n        this.#optimization = optimization;\n        let value = 0;\n        for (let i = 0; i < this.#clients.length; i += 1) {\n            const c = this.#clients[i];\n            value += c.score;\n        }\n        this.#score = value / this.#clients.length;\n    }\n\n    #getRandomClient(): Client {\n        return this.#clients[Math.floor(Math.random() * this.#clients.length)];\n    }\n\n    reset() {\n        this.#representative = this.#getRandomClient();\n        this.goExtinct();\n        this.#clients.push(this.#representative);\n        this.#representative.species = this;\n        this.#score = 0;\n    }\n\n    kill(survivors = 0.5) {\n        this.#clients.sort((a, b) => {\n            return a.score > b.score ? -1 : 1;\n        });\n\n        const elems = survivors * this.#clients.length;\n        for (let i = this.#clients.length - 1; i > elems; i -= 1) {\n            if (this.#clients[i].bestScore) {\n                continue;\n            }\n            this.#clients[i].species = null;\n            this.#clients.splice(i, 1);\n        }\n    }\n\n    breed(): Genome {\n        const c1 = this.#getRandomClient();\n        const c2 = this.#getRandomClient();\n        if (c1.score >= c2.score) {\n            return Genome.crossOver(c1.genome, c2.genome);\n        } else {\n            return Genome.crossOver(c2.genome, c1.genome);\n        }\n    }\n\n    size(): number {\n        return this.#clients.length;\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { Neat } from './neat';\n"],"names":["root","factory","exports","module","define","amd","self","constructor","genome","nodes","connections","nodeHashmap","Map","i","data","length","n","ConnectionGene","node","Node","x","set","innovationNumber","this","push","sort","a","b","compereTo","c","NodeGene","from","to","nodeFrom","get","nodeTo","con","Connection","weight","enabled","calculate","input","Error","output","Array","value","sum","Math","exp","Set","contains","gene","randomElement","size","floor","random","add","addSorted","innovation","splice","clear","index","remove","arg","indexOf","delete","survivors","object","score","randomScore","abs","scoreIndex","reset","Gene","super","replaceIndex","getHashKey","equals","obj","hashCode","Neat","MAX_NODES","neat","RandomHashSet","OPT_ERR_TRASHHOLD","selfOpt","optErrTrashhold","distance","g2","g1","higGene1","higGene2","tempG","indexG1","indexG2","disjoint","weightDiff","similar","gene1","gene2","inn1","inn2","excess","N","max","CT","C1","C2","C3","static","emptyGenome","addedCon","optimization","getConnection","conn","mutateLink","geneA","geneB","temp","exists","forEach","item","WEIGHT_RANDOM_STRENGTH","mutateNode","getReplaceIndex","middle","getNode","y","setReplaceIndex","con1","con2","exists1","exists2","mutateWeightShift","newWeight","WEIGHT_SHIFT_STRENGTH","mutateWeightRandom","mutateLinkToggle","mutate","prob","PROBABILITY_MUTATE_NODES","PROBABILITY_MUTATE_LINK","PROBABILITY_MUTATE_TOGGLE_LINK","PROBABILITY_MUTATE_WEIGHT_RANDOM","PROBABILITY_MUTATE_WEIGHT_SHIFT","maxWeight","bestScore","error","species","generateCalculator","Calculator","client","inputNodes","outputNodes","clients","pow","allConnections","allNodes","CP","nodeGene","Client","node1","node2","hashKey","foundCon","Genome","connectionGene","has","id","printSpecies","console","log","evolve","selector","RandomSelector","s","breed","put","goExtinct","kill","found","k","Species","evaluateScore","maxScore","bestScoreSet","minScore","Infinity","cof","allCons","sqrt","force","elems","c1","c2","crossOver","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}